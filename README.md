# yads-bash-software-design

![github actions](https://github.com/keygang/yads-bash-software-design/actions/workflows/github-actions.yml/badge.svg)
[![codecov.io](http://codecov.io/github/keygang/yads-bash-software-design/coverage.svg?branch=development)](http://codecov.io/github/keygang/yads-bash-software-design?branch=development)

## Build

Тестировалось только на MacOS и Ubuntu.

```bash
mkdir build
cd build
cmake ..
make
```

## Запуск
Из корневой директории
```bash
./build/src/bash
```

## Lint
Используется `clang-format-13`. Для запуска автоформата запустите
```bash
./scripts/format.sh
```


## Команды
- [cat](#Cat);
- [echo](#Echo);
- [wc](#Wc);
- [pwd](#Pwd);
- [exit](#Exit);
- [присваивание переменной](#Присваивание-переменной);
- [cd](#Cd);
- [ls](#Ls);
- [исполняемый файл](#исполняемый-файл ).
### Cat
`cat <FILE>` — вывести на экран содержимое файла.

Если комманда введена без аргументов, в поток ошибок выводится ошибка `Enter the file please`.

Если количество агрументов больше одного, остальные агрументы игнорируются.

В пайплайне, в качестве агрумента берет поток вывода (если он есть).

### Echo
`echo [ARGS]` — вывести на экран свой аргумент (или аргументы).

Пример:
```bash
% echo hello "world" '!' "$x" '$x'
hello world ! 5 $x
```

В пайплайне, в качестве агрументов берет поток вывода (если они есть).

### Wc
`wc <FILE>` — вывести количество строк, слов и байт в файле.

Пример:
```bash
% wc bash
1255	11419	1663440
```
Если комманда введена без аргументов, в поток ошибок выводится ошибка `Enter the file please`.

Если введен некоректный файл в поток ошибок выводится ошибка `Can't open file`

Если количество агрументов больше одного, остальные агрументы игнорируются.

В пайплайне, в качестве агрументов берет поток вывода (если они есть).

### Pwd
`pwd` — распечатать текущую директорию.
```bash
% pwd wdaw
/Users/stasbokun/yads-bash-software-design/cmake-build-debug/src
```
Если количество агрументов больше нуля, агрументы игнорируются.

### Exit
`exit` — выйти из bash.

Если количество агрументов больше нуля, агрументы игнорируются.

В пайплайне также завершает работу bash, не выполняя остальные команды.

### Присваивание переменной
`VAR=VALUE` — присвоить значение переменной.
В пайплайне, присвоение сработает только после выполнения всех команд из пайплайна! `x="2" | echo $x` — НЕ РАБОТАЕТ!
- `x="2" | echo $x` — НЕ РАБОТАЕТ! Выводится пустота

Если `VALUE` не было введено:
```bash
src % x=
src % There is no value for x
```

### Cd
`cd <PATH>` - переместиться в другую дерикторию.

Примеры:
```bash
src % pwd
/Users/stasbokun/yads-bash-software-design/cmake-build-debug/src
src % cd ..
cmake-build-debug % pwd
/Users/stasbokun/yads-bash-software-design/cmake-build-debug
cmake-build-debug % cd /Users/stasbokun/yads-bash-software-design
yads-bash-software-design % pwd
/Users/stasbokun/yads-bash-software-design
```

Если комманда введена без аргументов, в поток ошибок выводится ошибка `Enter the path please`.

Если количество агрументов больше одного, агрументы игнорируются.

В пайплайне, в качестве агрументов берет поток вывода (если они есть).

### Ls
`ls` - вывести файлы/дериктории в текущей директории.

Пример
```bash
cmake-build-debug % cd src
src % ls
CMakeFiles
cmake_install.cmake
libbash-lib.a
bash
```

Если количество агрументов больше нуля, агрументы игнорируются.

### Исполняемый файл

Запускает исполняемый файл с переменными которые были установлены в `bash`.

В пайплайне, в качестве агрументов берет поток вывода (если они есть).

Пример:
```bash
files % echo.sh
Hello world!
```

### Подстановки
Подстановки не выполняются в одинарных кавычках, даже если подставка внутри двоиных (`echo "'$p'"` выведет `'$p'`).
Подставновки работают в двойных кавычках, и без каких-либо кавычек, примеры подстановок:
```bash
src % x=ex
src % y=it
src % $x$y

Process finished with exit code 0
```
```bash
src % x=1
src % echo $x
1
```
```bash
src % x=' 1 '
src % echo $x
1
src % echo "$x"
 1 
src % 
```

## Описание

У нас будет 2 основные компоненты:

`Parser` и `Executer`

## Parser

1. Принимает input.
2. `CommandSplitter` — парсит комманды. Сплиттим на команды по | вне кавычек.
   2.1. `ParseCommandAndArguments` — парсит отдельно комманду/агрументы.

   2.2. `Substitution` — производит подстановку переменных соответствуя правилам.
3. Возвращает `Pipeline` пайплайн (удаляя инициализацию переменных) или одну команду.

### Особенности

- Операторы пайплайна, присваивания, определяются символами =, | без кавычек, если эти символы находятся внутри кавычек – это просто строка.
- Оператор $ не выполняет подстановку внутри одинарных кавычек, а также  в ходе исполнения pipeline, подстановка выполняется один раз на этапе парсинга.
- Внутри пайплайна нельзя сделать подстановку переменных, которые присваиваются в этом же пайплайне.
```bash
src % p=1 | echo $p lol
lol
```

## Executer

1. `ExecuteCommands` — выполняет комманды.

   1.1. `ExcuteCommand` — выполняет первую в очереди команду.

   1.2. Выводит в stderr в случае ошибки

   1.3. Возвращает `CommandResponse` состояший из stdout команды, и status code.

   1.4. Если команд не осталось — выходим.

   1.5. Если еще остались команды, сохраняем `CommandResponse`, и отправляем stdout в следующую команжу и запускаем 1.1.
2. Выводим последний stdout.

### Особенности:

Если в `Exexutor` передан `Pipeline` и в текущей команде код возврата 0, эта команда подает вывод на вход следующей команды.

Если возникла ошибка в `Pipeline`, просто выполняет следующую команду.

## Диаграмма
Сыллка на диаграмму https://drive.google.com/file/d/1q-_mMVWoTSVS6rWc0qTotnG52RHVGR_T/view?usp=sharing

Голубым обочначены компоненты, которые будут реализованы во второй фазе реализации. В первой части будет реализовано все остальное.
